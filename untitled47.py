# -*- coding: utf-8 -*-
"""Untitled47.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/sukriramli/hs-2022-explorer/blob/main/Untitled47.ipynb
"""

import pandas as pd
import os
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML
from textblob import TextBlob
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import gensim
from gensim.models import Word2Vec
import joblib
from joblib import Parallel, delayed

# 1. Data Loading
repo_url = "https://github.com/datasets/harmonized-system.git"
repo_name = "harmonized-system"

if not os.path.exists(repo_name):
    os.system(f"git clone {repo_url}")

data_dir = f"./{repo_name}/data"
file_name = 'harmonized-system.csv'
file_path = os.path.join(data_dir, file_name)

try:
    df = pd.read_csv(file_path, low_memory=True)
    print("Data loaded successfully!")
except Exception as e:
    print(f"Error loading data: {e}")
    exit()

# 2. Data Cleaning and Preprocessing
def clean_text(text):
    if isinstance(text, str):
        text = text.lower()
        text = re.sub(r'[^\w\s]', '', text)
        return text
    return ""

if 'description' in df.columns:
    df['cleaned_description'] = df['description'].apply(clean_text)

if 'section' in df.columns:
    section_counts = df['section'].value_counts()
    top_20_sections = section_counts.index[:20]
    df_top20 = df[df['section'].isin(top_20_sections)]

if 'description' in df.columns:
    df['sentiment'] = df['description'].apply(lambda x: TextBlob(x).sentiment.polarity if isinstance(x, str) else 0)

# 3. Train Relevance Prediction Model (using dummy relevance data for demonstration)
df['relevance'] = (df['sentiment'] + 1) / 2  # Dummy relevance based on sentiment
X = df[['sentiment']]
y = df['relevance']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = LinearRegression()
model.fit(X_train, y_train)

# 4. Train Custom Word Embedding Model
sentences = df['cleaned_description'].apply(lambda x: x.split()).tolist()
custom_model = Word2Vec(sentences, vector_size=100, window=5, min_count=1, workers=4)
custom_model.save('custom_word2vec_model.model')

# Load the custom word embedding model
custom_model = Word2Vec.load('custom_word2vec_model.model')

# --- Searchbox and Search Functionality ---

def search_descriptions(search_term):
    search_term = search_term.lower()

    # Combine relevant columns for searching
    df['combined_text'] = df['cleaned_description'].astype(str) + ' ' + \
                          df['hscode'].astype(str) + ' ' + \
                          df['section'].astype(str)

    # Check if the search term is numeric (HS code)
    if search_term.isdigit():
        results = df[df['hscode'].astype(str).str.contains(search_term, na=False, regex=False)].copy()
        # Ensure 'predicted_relevance' column is created and cast to float
        if 'predicted_relevance' not in results.columns:
            results['predicted_relevance'] = 0.0
        results['predicted_relevance'] = 1.0  # Assign a default relevance for HS code search
    else:
        # Calculate TF-IDF vectors
        vectorizer = TfidfVectorizer()
        tfidf_matrix = vectorizer.fit_transform(df['combined_text'])
        search_vector = vectorizer.transform([search_term])

        # Calculate cosine similarity
        from sklearn.metrics.pairwise import cosine_similarity
        cosine_similarities = cosine_similarity(search_vector, tfidf_matrix).flatten()
        df['relevance'] = cosine_similarities

        # Predict relevance (using .loc to avoid SettingWithCopyWarning)
        results = df[df['combined_text'].str.contains(search_term, na=False, regex=False)].copy()

        # Ensure 'predicted_relevance' column is created and cast to float
        if 'predicted_relevance' not in results.columns:
            results['predicted_relevance'] = 0.0

        # Check if there are any results before predicting relevance
        if not results.empty:
            # Predict relevance and assign to results DataFrame using .loc
            results.loc[:, 'predicted_relevance'] = model.predict(results[['sentiment']])

            # Filter and sort results
            results = results.sort_values(by='predicted_relevance', ascending=False)

    if results.empty:
        print(f"No results found for '{search_term}'. Try these:")
        # Suggest related terms or categories (implementation not shown here)
    else:
        if 'predicted_relevance' in results.columns:
            results['relevance_percent'] = (results['predicted_relevance'] / results['predicted_relevance'].max()) * 100
            with pd.option_context('display.max_rows', None, 'display.max_colwidth', 0):
                display(results[['hscode', 'description', 'section', 'sentiment', 'relevance_percent']])
        else:
            print("No predicted relevance found for the search results.")

    # Suggest related terms only if the search term is not numeric
    if not search_term.isdigit():
        try:
            suggestions = custom_model.wv.most_similar(search_term, topn=5)
            print("Related terms:", suggestions)
        except KeyError:
            print(f"No related terms found for '{search_term}' in the word embedding model.")

    # Re-display the search box and button
    display_search_box()

def display_search_box():
    # Create searchbox widget with updated placeholder text
    search_box = widgets.Text(placeholder='Enter HS code (4 digits) or words', layout=widgets.Layout(width='300px'))

    # Create search button widget
    search_button = widgets.Button(description='Search', button_style='success', layout=widgets.Layout(width='100px'))

    # Define button click event
    def on_button_click(b):
        clear_output()
        search_term = search_box.value.lower()
        search_descriptions(search_term)

    search_button.on_click(on_button_click)

    # Create a fixed layout for the search box and button
    fixed_layout = widgets.Layout(position='fixed', top='0px', width='100%', background_color='#f0f0f0', padding='10px')
    search_box_container = widgets.HBox([search_box, search_button], layout=fixed_layout)

    # Display searchbox and button with fixed layout
    display(search_box_container)

# Add custom CSS for additional styling
display(HTML("""
<style>
    .widget-hbox {
        justify-content: center;
        align-items: center;
    }
    .widget-text {
        font-size: 14px;
        padding: 5px;
    }
    .widget-button {
        font-size: 14px;
        padding: 5px;
    }
    .title {
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        margin-bottom: 20px;
    }
</style>
"""))

# Display the title
display(HTML('<div class="title">WCO HS 2022 Explorer</div>'))

# Initial display of the search box and button
display_search_box()